Authentication and access delegations
=====================================

Introduction
------------

In this document, we will cover how to protect the usage of the cozy-stack.
When the cozy-stack receives a request, it checks that the request is
authorized, and if yes, it processes it and answers it.


What about OAuth2?
------------------

TODO what is OAuth2, what it aims to do
TODO the 4 actors
TODO what is in OAuth2 and what is left as an exercise to the reader
TODO the 4 grant types and the 3 ways to send the access token
  -> Authorization code
  -> Implicit grant type
  -> Client credentials grant type
  -> Resource owner credentials grant type

TODO list assumptions made in OAuth2
  -> TLS
  -> trust on first use principle

If you want to learn OAuth 2 in details, I recommend the [OAuth 2 in Action
book](https://www.manning.com/books/oauth-2-in-action).


The cozy stack as an authorization server
-----------------------------------------

### GET /auth/login

Display a form with a password field to let the user authenticates herself to
the cozy stack.

This endpoint accepts a `redirect` parameter. If the user is already logged
in, she will be redirected immediately. Else, the parameter will be transfered
in the POST. This parameter can only contain a link to an application
installed on the cozy (thus to a subdomain of the cozy instance). To protect
against stealing authorization code with redirection, the fragment is always
overriden:

```http
GET /auth/login?redirect=https://contacts.cozy.example.org/foo?bar#baz HTTP/1.1
Host: cozy.example.org
Cookies: ...
```

**Note**: the redirect parameter should be URL-encoded. We haven't done that
to make it clear what the path (`foo`), the query-string (`bar`), and the
fragment (`baz`) are.

```http
HTTP/1.1 302 Moved Temporarily
Location: https://contacts.cozy.example.org/foo?bar#_=_
```

If the `redirect` parameter is invalid, the response will be `400 Bad
Request`.

### POST /auth/login

After the user has typed her password and clicked on `Login`, a request is
made to this endpoint.

The `redirect` parameter is passed inside the body. If it is missing, the
redirection will be made against the default target: the home application of
this cozy instance.

```http
POST /auth/login HTTP/1.1
Host: cozy.example.org
Content-type: application/x-www-form-urlencoded

password=p4ssw0rd&redirect=https%3A%2F%2Fcontacts.cozy.example.org
```

```http
HTTP/1.1 302 Moved Temporarily
Set-Cookie: ...
Location: https://contacts.cozy.example.org/foo
```

### POST /auth/register

This route is used by OAuth2 clients to dynamically register them-selves.

See [OAuth 2.0 Dynamic Client Registration
Protocol](https://tools.ietf.org/html/rfc7591) for the details.

It gives to the client these informations:

- `client_id`
- `client_secret`
- `registration_access_token`

### GET /auth/register/:client-id
### PUT /auth/register/:client-id
### DELETE /auth/register/:client-id

These routes follow the [OAuth 2.0 Dynamic Client Registration Management
Protocol RFC](https://tools.ietf.org/html/rfc7592). They allow an OAuth2
client to get back its metadata, update them, and unregister itself.

The client has to sent its registration access token to be able to use this
endpoint.

### GET /auth/authorize

When an OAuth2 client wants to get access to the data of the cozy owner, it
starts the OAuth2 dance with this step. The user is shown what the client asks
and has an accept button if she is OK with that.

The parameters are:

- `client_id`, that identify the client
- `redirect_uri`, it has be exactly the same of the one used in registration
- `state`, it's a protection against CSRF on the client (a random string
  generated by the client, that it can check when the user will be redirected
  with the authorization code)
- `response_type`, only `code` is supported
- `scope`, a space separated list of the permissions asked (a permission being
  formatted as `key:access`, like `files/images:read`).

```http
GET /auth/authorize?client_id=oauth-client-1&response_type=code&scope=files/images:read%20data/io.cozy.contacts:read&state=Eh6ahshepei5Oojo&redirect_uri=https%3A%2F%2Fclient.org%2F HTTP/1.1
Host: cozy.example.org
```

**Note** we follow the TOFU principle (Trust On First Use). It means that if
the user has already said yes for this authorization and scopes, she will be
redirected to the app directly. As for `/auth/login`, the fragment is
overriden in the redirection with `#_=_`.

### POST /auth/authorize

When the user accepts, her browser send a request to this endpoint:

```http
POST /auth/authorize
Host: cozy.example.org
Content-type: x-www-form-urlencoded

approve=Approve&csrf-token=johw6Sho
```

**Note**: this endpoint is protected against CSRF attacks.

The user is then redirected to the original client, with an access code in the
URL:

```http
HTTP/1.1 302 Moved Temporarily
Location: https://client.org/?state=Eh6ahshepei5Oojo&access_code=Aih7ohth
```

### POST /auth/access_token

Now, the client can check that the state is correct, and if it is the case,
ask for an `access_token`. It can use this route with the `code` (ie
access_code) given below.

This endpoint is also used to refresh the access token, by sending the
`refresh_token` instead of the `access_code`.

The parameters are:

- `grant_type`, with `authorization_code` or `refresh_token` as value
- `code` or `refresh_token`, depending on which grant type is used
- `client_id`
- `client_secret`

Example:

```http
POST /auth/access_token
Host: cozy.example.org
Content-type: x-www-form-urlencoded
Accept: application/json

grant_type=authorization_code&code=Aih7ohth&client_id=oauth-client-1&client_secret=Oung7oi5
```

```http
HTTP/1.1 200 OK
Content-type: application/json

{
  "access_token": "ooch1Yei",
  "token_type": "bearer",
  "refresh_token": "ui0Ohch8",
  "scope": "files/images:read data/io.cozy.contacts:read"
}
```

### FAQ

> What format is used for tokens?

The tokens are formatted as [JSON Web Tokens (JWT)](https://jwt.io/).

> What happens when the user has lost her password?

She can reset it from the command-line, like this:

```sh
$ cozy-stack instances reset-password cozy.example.org
ek0Jah1R
```

A new password is generated and print in the console.

> Is two-factor authentication (2FA) possible?

Yes, it's possible.

**TODO:** explain how


Client-side apps
----------------

**Important**: OAuth2 is not used here! The steps looks similar (like obtaining
a token), but when going in the details, it doesn't match.

### How to register the application?

The application is registered at install. See [app management](apps.md) for
details.

### How to get a token?

When a user access an application, she first loads the HTML page. Inside this
page, the `<body>` tag has a `data-cozy-token` attribute with a token. This
token is specific to a context, that can be either public or private.

We have prefered our custom solution to the implicit grant type of OAuth2 for
2 reasons:

1. It has a better User Experience. The implicit grant type works with 2
redirections (the application to the stack, and then the stack to the
application), and the first one needs JS to detect if the token is present or
not in the fragment hash. It has a strong impact on the time to load the
application.

2. The implicit grant type of OAuth2 has a severe drawback on security: the
token appears in the URL and is shown by the browser. It can also be leaked
with the HTTP `Referer` header.

### How to use a token?

The token can be sent to the cozy-stack in the query-string, like this:

```http
GET /data/io.cozy.events/6494e0ac-dfcb-11e5-88c1-472e84a9cbee?CtxToken=e7af77ba2c2dbe2d
HOST: cozy.example.org
```

If the user is authenticated, her cookies will be sent automatically. The
cookies are needed for a token to a private context to be valid.

### How to refresh a token?

The context token is valid only for 24 hours. If the application is opened for
more than that, it will need to get a new token. But most applications won't
be kept open for so long and it's okay if they don't try to refresh tokens. At
worst, the user just had to reload its page and it will work again.

The app can know it's time to get a new token when the stack starts sending
401 Unauthorized responses. In that case, it can fetches the same html page
that it was loaded initially, parses it and extracts the new token.


Devices and browser extensions
------------------------------

### How to register the application?

https://tools.ietf.org/html/draft-ietf-oauth-native-apps-05
[PKCE](https://tools.ietf.org/html/rfc7636) and chapter 10

https://developer.chrome.com/apps/app_identity#non
https://developer.chrome.com/apps/identity#method-getRedirectURL
https://github.com/AdrianArroyoCalle/firefox-addons/blob/master/addon-google-oauth2/addon-google-oauth2.js#L26

### How to get a token?

### How to use a token?

### How to refresh a token?


Third-party websites
--------------------

### How to register the application?

See chapter 12

### How to get a token?

Chapter 11 about JWT

### How to use a token?

### How to refresh a token?


Security considerations
-----------------------

See https://tools.ietf.org/html/rfc6749#page-53
and https://tools.ietf.org/html/rfc6819
and https://tools.ietf.org/html/draft-ietf-oauth-closing-redirectors-00
and http://www.oauthsecurity.com/

Dynamically registered applications won't have access to some scopes. For
example, an application that has been dynamically registered can't ask the
cozy owner to give it the right to install other applications. This limitation
should improve security, as avoiding too powerful scopes to be used with
unknown applications.

TODO: rate limiting
TODO: no CORS for `/auth`
